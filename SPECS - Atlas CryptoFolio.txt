# SPECS - Atlas CryptoFolio

## STACK TECNOL√ìGICA

### Frontend
- **Framework:** Next.js 14+ (App Router)
- **Linguagem:** TypeScript 5+
- **UI Library:** shadcn/ui + Radix UI
- **Styling:** Tailwind CSS 3.4+
- **State Management:** 
  - Zustand (client state)
  - TanStack Query v5 (server state)
- **Forms:** React Hook Form + Zod
- **Charts:** Recharts (gr√°ficos de performance e distribui√ß√£o)
- **Tables:** TanStack Table v8 (tabelas de ativos e transa√ß√µes)
- **Dates:** date-fns (manipula√ß√£o de datas)
- **Decimals:** Decimal.js (precis√£o em c√°lculos financeiros)
- **Icons:** Lucide React
- **Notifications:** Sonner (toast notifications)

### Backend & Database
- **Database:** Supabase (PostgreSQL)
- **ORM:** Drizzle ORM
- **API:** Next.js Server Actions
- **Realtime:** Supabase Realtime (atualiza√ß√£o de pre√ßos)
- **Storage:** Supabase Storage (comprovantes de transa√ß√µes)
- **Cron Jobs:** Vercel Cron (atualiza√ß√£o de pre√ßos)

### Autentica√ß√£o
- **Provider:** Clerk
- **Features:** Organizations (multi-tenant), OAuth, Session Management
- **Sync:** Webhooks Clerk ‚Üí Supabase
- **OAuth Providers:** Google, GitHub, Email/Password

### Email
- **Provider:** Resend
- **Templates:** React Email
- **Tipos:** 
  - Boas-vindas
  - Alertas de pre√ßo
  - Insights semanais
  - Convites de organiza√ß√£o
  - Recupera√ß√£o de conta

### Infraestrutura
- **Hosting:** Vercel (Edge Functions)
- **Repository:** GitHub
- **CI/CD:** GitHub Actions + Vercel
- **Monitoring:** Vercel Analytics + Sentry
- **Analytics:** Vercel Analytics + PostHog (events tracking)

### Integra√ß√µes Externas
- **Pre√ßos Cripto:** CoinGecko API (prim√°rio), CoinMarketCap API (fallback)
- **Not√≠cias:** CryptoNews API, NewsAPI
- **Market Data:** Fear & Greed Index API

---

## ARQUITETURA MULTI-TENANT

### Estrat√©gia: Row-Level Security (RLS) via Supabase

**Por qu√™?**
- Isolamento garantido no n√≠vel do banco
- Supabase RLS policies nativas
- Menor custo operacional que database-per-tenant
- Escala bem at√© 10k+ organiza√ß√µes
- Sem complexidade de schema multitenancy
- Performance adequada com indexes corretos

### Tenant Context Flow
```
Request ‚Üí Clerk Auth ‚Üí Extract Org ID ‚Üí Set Supabase RLS Context ‚Üí Query com RLS
```

**Implementa√ß√£o:**

```typescript
// lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { auth } from '@clerk/nextjs';

export async function createSupabaseServerClient() {
  const { orgId } = auth();
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
      },
      global: {
        headers: {
          // Define o context do RLS
          'x-organization-id': orgId || '',
        },
      },
    }
  );
}
```

**RLS Policy Pattern:**
```sql
-- Padr√£o para todas as tabelas multi-tenant
CREATE POLICY "tenant_isolation_policy"
  ON table_name
  FOR ALL
  USING (organization_id = current_setting('request.headers')::json->>'x-organization-id');
```

---

## SCHEMA DO BANCO DE DADOS (SUPABASE)

### Conven√ß√µes
- Todas as tabelas multi-tenant t√™m `organization_id UUID NOT NULL`
- RLS policies em TODAS as tabelas
- Soft deletes: `deleted_at TIMESTAMPTZ`
- Audit trail: `created_at`, `updated_at`
- UUIDs para IDs (`gen_random_uuid()`)
- snake_case para nomes de colunas
- Timestamps sempre com timezone (`TIMESTAMPTZ`)

### Tabela: organizations

```sql
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_org_id TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  plan TEXT NOT NULL DEFAULT 'free', -- 'free', 'premium'
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_organizations_clerk_org_id ON organizations(clerk_org_id);
CREATE INDEX idx_organizations_slug ON organizations(slug);

-- RLS Policies
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their organizations"
  ON organizations FOR SELECT
  USING (clerk_org_id = current_setting('request.headers')::json->>'x-clerk-org-id');

CREATE POLICY "Service role has full access"
  ON organizations FOR ALL
  USING (true);
```

### Tabela: users

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_user_id TEXT UNIQUE NOT NULL,
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  
  email TEXT NOT NULL,
  name TEXT,
  avatar_url TEXT,
  
  -- Preferences
  preferred_currency TEXT DEFAULT 'USD', -- 'USD', 'BRL', 'EUR'
  timezone TEXT DEFAULT 'UTC',
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_users_clerk_user_id ON users(clerk_user_id);
CREATE INDEX idx_users_organization_id ON users(organization_id);
CREATE INDEX idx_users_email ON users(email);

-- RLS Policies
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view users in their organization"
  ON users FOR SELECT
  USING (organization_id::text = current_setting('request.headers')::json->>'x-organization-id');

CREATE POLICY "Users can update their own profile"
  ON users FOR UPDATE
  USING (clerk_user_id = current_setting('request.headers')::json->>'x-clerk-user-id');
```

### Tabela: wallets

```sql
CREATE TABLE wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  name TEXT NOT NULL,
  description TEXT,
  goal TEXT, -- 'long_term', 'trading', 'defi', 'custom'
  color TEXT DEFAULT '#3b82f6', -- Hex color
  icon TEXT DEFAULT 'wallet', -- Icon identifier
  is_default BOOLEAN DEFAULT false,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_wallets_organization_id ON wallets(organization_id);
CREATE INDEX idx_wallets_user_id ON wallets(user_id);
CREATE INDEX idx_wallets_created_at ON wallets(created_at DESC);

-- RLS Policies
ALTER TABLE wallets ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage wallets in their organization"
  ON wallets FOR ALL
  USING (organization_id::text = current_setting('request.headers')::json->>'x-organization-id');

-- Constraint: Apenas uma wallet default por user
CREATE UNIQUE INDEX idx_wallets_user_default 
  ON wallets(user_id) 
  WHERE is_default = true AND deleted_at IS NULL;
```

### Tabela: assets

```sql
CREATE TABLE assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  
  -- CoinGecko/CoinMarketCap ID
  coingecko_id TEXT UNIQUE NOT NULL,
  symbol TEXT NOT NULL, -- 'BTC', 'ETH'
  name TEXT NOT NULL, -- 'Bitcoin', 'Ethereum'
  
  -- Metadata
  logo_url TEXT,
  description TEXT,
  website_url TEXT,
  categories TEXT[], -- ['layer-1', 'proof-of-work']
  
  -- Market data (atualizado periodicamente)
  current_price_usd NUMERIC(20, 8),
  market_cap_usd NUMERIC(20, 2),
  volume_24h_usd NUMERIC(20, 2),
  price_change_24h NUMERIC(10, 4), -- Percentage
  last_updated TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_assets_coingecko_id ON assets(coingecko_id);
CREATE INDEX idx_assets_symbol ON assets(symbol);
CREATE INDEX idx_assets_name ON assets(name);

-- RLS: Assets s√£o p√∫blicos, todos podem ler
ALTER TABLE assets ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Assets are publicly readable"
  ON assets FOR SELECT
  USING (true);

CREATE POLICY "Only service role can modify assets"
  ON assets FOR ALL
  USING (current_user = 'service_role');
```

### Tabela: transactions

```sql
CREATE TABLE transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  wallet_id UUID NOT NULL REFERENCES wallets(id) ON DELETE CASCADE,
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE RESTRICT,
  
  -- Transaction details
  type TEXT NOT NULL, -- 'buy', 'sell', 'transfer', 'airdrop'
  quantity NUMERIC(20, 8) NOT NULL,
  price_per_unit_usd NUMERIC(20, 8) NOT NULL,
  total_value_usd NUMERIC(20, 2) NOT NULL,
  fee_usd NUMERIC(20, 2) DEFAULT 0,
  
  -- Additional context
  exchange TEXT, -- 'binance', 'coinbase', etc
  notes TEXT,
  receipt_url TEXT, -- Supabase Storage URL
  
  -- Timestamp
  transaction_date TIMESTAMPTZ NOT NULL,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_transactions_organization_id ON transactions(organization_id);
CREATE INDEX idx_transactions_wallet_id ON transactions(wallet_id);
CREATE INDEX idx_transactions_asset_id ON transactions(asset_id);
CREATE INDEX idx_transactions_date ON transactions(transaction_date DESC);
CREATE INDEX idx_transactions_type ON transactions(type);

-- RLS Policies
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage transactions in their organization"
  ON transactions FOR ALL
  USING (organization_id::text = current_setting('request.headers')::json->>'x-organization-id');

-- Constraint: Quantidade sempre positiva
ALTER TABLE transactions ADD CONSTRAINT transactions_quantity_positive 
  CHECK (quantity > 0);

-- Constraint: Tipos v√°lidos
ALTER TABLE transactions ADD CONSTRAINT transactions_valid_type
  CHECK (type IN ('buy', 'sell', 'transfer', 'airdrop'));
```

### Tabela: holdings

```sql
-- Tabela materializada para performance (calculada a partir de transactions)
CREATE TABLE holdings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  wallet_id UUID NOT NULL REFERENCES wallets(id) ON DELETE CASCADE,
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE RESTRICT,
  
  -- Calculated values
  total_quantity NUMERIC(20, 8) NOT NULL DEFAULT 0,
  average_buy_price_usd NUMERIC(20, 8) NOT NULL DEFAULT 0,
  total_invested_usd NUMERIC(20, 2) NOT NULL DEFAULT 0,
  realized_pnl_usd NUMERIC(20, 2) NOT NULL DEFAULT 0,
  
  -- Metadata
  last_calculated_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_holdings_organization_id ON holdings(organization_id);
CREATE INDEX idx_holdings_wallet_id ON holdings(wallet_id);
CREATE INDEX idx_holdings_asset_id ON holdings(asset_id);
CREATE UNIQUE INDEX idx_holdings_wallet_asset ON holdings(wallet_id, asset_id) 
  WHERE total_quantity > 0;

-- RLS Policies
ALTER TABLE holdings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view holdings in their organization"
  ON holdings FOR SELECT
  USING (organization_id::text = current_setting('request.headers')::json->>'x-organization-id');

CREATE POLICY "Service role has full access to holdings"
  ON holdings FOR ALL
  USING (true);
```

### Tabela: price_snapshots

```sql
CREATE TABLE price_snapshots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  
  price_usd NUMERIC(20, 8) NOT NULL,
  market_cap_usd NUMERIC(20, 2),
  volume_24h_usd NUMERIC(20, 2),
  
  snapshot_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_price_snapshots_asset_id ON price_snapshots(asset_id);
CREATE INDEX idx_price_snapshots_snapshot_at ON price_snapshots(snapshot_at DESC);
CREATE INDEX idx_price_snapshots_asset_date ON price_snapshots(asset_id, snapshot_at DESC);

-- RLS: Price snapshots s√£o p√∫blicos
ALTER TABLE price_snapshots ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Price snapshots are publicly readable"
  ON price_snapshots FOR SELECT
  USING (true);

CREATE POLICY "Only service role can insert price snapshots"
  ON price_snapshots FOR INSERT
  WITH CHECK (current_user = 'service_role');
```

### Tabela: insights

```sql
CREATE TABLE insights (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  wallet_id UUID REFERENCES wallets(id) ON DELETE CASCADE, -- NULL = all wallets
  
  type TEXT NOT NULL, -- 'concentration', 'performance', 'rebalancing', 'alert'
  severity TEXT NOT NULL, -- 'info', 'warning', 'critical'
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  metadata JSONB, -- Dados espec√≠ficos do insight
  
  is_read BOOLEAN DEFAULT false,
  is_applied BOOLEAN DEFAULT false,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ, -- Insights podem expirar
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_insights_organization_id ON insights(organization_id);
CREATE INDEX idx_insights_wallet_id ON insights(wallet_id);
CREATE INDEX idx_insights_type ON insights(type);
CREATE INDEX idx_insights_created_at ON insights(created_at DESC);
CREATE INDEX idx_insights_is_read ON insights(is_read) WHERE is_read = false;

-- RLS Policies
ALTER TABLE insights ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage insights in their organization"
  ON insights FOR ALL
  USING (organization_id::text = current_setting('request.headers')::json->>'x-organization-id');
```

### Tabela: news_bookmarks

```sql
CREATE TABLE news_bookmarks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  news_url TEXT NOT NULL,
  title TEXT NOT NULL,
  source TEXT,
  published_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_news_bookmarks_organization_id ON news_bookmarks(organization_id);
CREATE INDEX idx_news_bookmarks_user_id ON news_bookmarks(user_id);
CREATE INDEX idx_news_bookmarks_created_at ON news_bookmarks(created_at DESC);

-- RLS Policies
ALTER TABLE news_bookmarks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own bookmarks"
  ON news_bookmarks FOR ALL
  USING (user_id::text = current_setting('request.headers')::json->>'x-clerk-user-id');
```

### Tabela: price_alerts

```sql
CREATE TABLE price_alerts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  
  type TEXT NOT NULL, -- 'above', 'below'
  target_price_usd NUMERIC(20, 8) NOT NULL,
  is_triggered BOOLEAN DEFAULT false,
  triggered_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ
);

-- Indexes
CREATE INDEX idx_price_alerts_organization_id ON price_alerts(organization_id);
CREATE INDEX idx_price_alerts_user_id ON price_alerts(user_id);
CREATE INDEX idx_price_alerts_asset_id ON price_alerts(asset_id);
CREATE INDEX idx_price_alerts_not_triggered ON price_alerts(is_triggered) 
  WHERE is_triggered = false;

-- RLS Policies
ALTER TABLE price_alerts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage their own alerts"
  ON price_alerts FOR ALL
  USING (user_id::text = current_setting('request.headers')::json->>'x-clerk-user-id');
```

---

## DRIZZLE ORM SCHEMA

```typescript
// lib/db/schema.ts
import { 
  pgTable, 
  text, 
  timestamp, 
  uuid, 
  numeric,
  boolean,
  jsonb,
  index,
  uniqueIndex
} from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

// Organizations
export const organizations = pgTable('organizations', {
  id: uuid('id').primaryKey().defaultRandom(),
  clerkOrgId: text('clerk_org_id').unique().notNull(),
  name: text('name').notNull(),
  slug: text('slug').unique().notNull(),
  plan: text('plan').notNull().default('free'),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
}, (table) => ({
  clerkOrgIdIdx: index('idx_organizations_clerk_org_id').on(table.clerkOrgId),
  slugIdx: index('idx_organizations_slug').on(table.slug),
}));

// Users
export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  clerkUserId: text('clerk_user_id').unique().notNull(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  
  email: text('email').notNull(),
  name: text('name'),
  avatarUrl: text('avatar_url'),
  
  preferredCurrency: text('preferred_currency').default('USD'),
  timezone: text('timezone').default('UTC'),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
}, (table) => ({
  clerkUserIdIdx: index('idx_users_clerk_user_id').on(table.clerkUserId),
  organizationIdIdx: index('idx_users_organization_id').on(table.organizationId),
  emailIdx: index('idx_users_email').on(table.email),
}));

// Wallets
export const wallets = pgTable('wallets', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  name: text('name').notNull(),
  description: text('description'),
  goal: text('goal'),
  color: text('color').default('#3b82f6'),
  icon: text('icon').default('wallet'),
  isDefault: boolean('is_default').default(false),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
}, (table) => ({
  organizationIdIdx: index('idx_wallets_organization_id').on(table.organizationId),
  userIdIdx: index('idx_wallets_user_id').on(table.userId),
  createdAtIdx: index('idx_wallets_created_at').on(table.createdAt),
}));

// Assets
export const assets = pgTable('assets', {
  id: uuid('id').primaryKey().defaultRandom(),
  
  coingeckoId: text('coingecko_id').unique().notNull(),
  symbol: text('symbol').notNull(),
  name: text('name').notNull(),
  
  logoUrl: text('logo_url'),
  description: text('description'),
  websiteUrl: text('website_url'),
  categories: text('categories').array(),
  
  currentPriceUsd: numeric('current_price_usd', { precision: 20, scale: 8 }),
  marketCapUsd: numeric('market_cap_usd', { precision: 20, scale: 2 }),
  volume24hUsd: numeric('volume_24h_usd', { precision: 20, scale: 2 }),
  priceChange24h: numeric('price_change_24h', { precision: 10, scale: 4 }),
  lastUpdated: timestamp('last_updated', { withTimezone: true }),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  coingeckoIdIdx: index('idx_assets_coingecko_id').on(table.coingeckoId),
  symbolIdx: index('idx_assets_symbol').on(table.symbol),
  nameIdx: index('idx_assets_name').on(table.name),
}));

// Transactions
export const transactions = pgTable('transactions', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  walletId: uuid('wallet_id').notNull().references(() => wallets.id, { onDelete: 'cascade' }),
  assetId: uuid('asset_id').notNull().references(() => assets.id, { onDelete: 'restrict' }),
  
  type: text('type').notNull(),
  quantity: numeric('quantity', { precision: 20, scale: 8 }).notNull(),
  pricePerUnitUsd: numeric('price_per_unit_usd', { precision: 20, scale: 8 }).notNull(),
  totalValueUsd: numeric('total_value_usd', { precision: 20, scale: 2 }).notNull(),
  feeUsd: numeric('fee_usd', { precision: 20, scale: 2 }).default('0'),
  
  exchange: text('exchange'),
  notes: text('notes'),
  receiptUrl: text('receipt_url'),
  
  transactionDate: timestamp('transaction_date', { withTimezone: true }).notNull(),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
}, (table) => ({
  organizationIdIdx: index('idx_transactions_organization_id').on(table.organizationId),
  walletIdIdx: index('idx_transactions_wallet_id').on(table.walletId),
  assetIdIdx: index('idx_transactions_asset_id').on(table.assetId),
  dateIdx: index('idx_transactions_date').on(table.transactionDate),
  typeIdx: index('idx_transactions_type').on(table.type),
}));

// Holdings
export const holdings = pgTable('holdings', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  walletId: uuid('wallet_id').notNull().references(() => wallets.id, { onDelete: 'cascade' }),
  assetId: uuid('asset_id').notNull().references(() => assets.id, { onDelete: 'restrict' }),
  
  totalQuantity: numeric('total_quantity', { precision: 20, scale: 8 }).notNull().default('0'),
  averageBuyPriceUsd: numeric('average_buy_price_usd', { precision: 20, scale: 8 }).notNull().default('0'),
  totalInvestedUsd: numeric('total_invested_usd', { precision: 20, scale: 2 }).notNull().default('0'),
  realizedPnlUsd: numeric('realized_pnl_usd', { precision: 20, scale: 2 }).notNull().default('0'),
  
  lastCalculatedAt: timestamp('last_calculated_at', { withTimezone: true }).defaultNow(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  organizationIdIdx: index('idx_holdings_organization_id').on(table.organizationId),
  walletIdIdx: index('idx_holdings_wallet_id').on(table.walletId),
  assetIdIdx: index('idx_holdings_asset_id').on(table.assetId),
}));

// Price Snapshots
export const priceSnapshots = pgTable('price_snapshots', {
  id: uuid('id').primaryKey().defaultRandom(),
  assetId: uuid('asset_id').notNull().references(() => assets.id, { onDelete: 'cascade' }),
  
  priceUsd: numeric('price_usd', { precision: 20, scale: 8 }).notNull(),
  marketCapUsd: numeric('market_cap_usd', { precision: 20, scale: 2 }),
  volume24hUsd: numeric('volume_24h_usd', { precision: 20, scale: 2 }),
  
  snapshotAt: timestamp('snapshot_at', { withTimezone: true }).defaultNow().notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  assetIdIdx: index('idx_price_snapshots_asset_id').on(table.assetId),
  snapshotAtIdx: index('idx_price_snapshots_snapshot_at').on(table.snapshotAt),
}));

// Insights
export const insights = pgTable('insights', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  walletId: uuid('wallet_id').references(() => wallets.id, { onDelete: 'cascade' }),
  
  type: text('type').notNull(),
  severity: text('severity').notNull(),
  title: text('title').notNull(),
  description: text('description').notNull(),
  metadata: jsonb('metadata'),
  
  isRead: boolean('is_read').default(false),
  isApplied: boolean('is_applied').default(false),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  expiresAt: timestamp('expires_at', { withTimezone: true }),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
}, (table) => ({
  organizationIdIdx: index('idx_insights_organization_id').on(table.organizationId),
  walletIdIdx: index('idx_insights_wallet_id').on(table.walletId),
  typeIdx: index('idx_insights_type').on(table.type),
  createdAtIdx: index('idx_insights_created_at').on(table.createdAt),
}));

// News Bookmarks
export const newsBookmarks = pgTable('news_bookmarks', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  newsUrl: text('news_url').notNull(),
  title: text('title').notNull(),
  source: text('source'),
  publishedAt: timestamp('published_at', { withTimezone: true }),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
}, (table) => ({
  organizationIdIdx: index('idx_news_bookmarks_organization_id').on(table.organizationId),
  userIdIdx: index('idx_news_bookmarks_user_id').on(table.userId),
  createdAtIdx: index('idx_news_bookmarks_created_at').on(table.createdAt),
}));

// Price Alerts
export const priceAlerts = pgTable('price_alerts', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  assetId: uuid('asset_id').notNull().references(() => assets.id, { onDelete: 'cascade' }),
  
  type: text('type').notNull(),
  targetPriceUsd: numeric('target_price_usd', { precision: 20, scale: 8 }).notNull(),
  isTriggered: boolean('is_triggered').default(false),
  triggeredAt: timestamp('triggered_at', { withTimezone: true }),
  
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow(),
  deletedAt: timestamp('deleted_at', { withTimezone: true }),
}, (table) => ({
  organizationIdIdx: index('idx_price_alerts_organization_id').on(table.organizationId),
  userIdIdx: index('idx_price_alerts_user_id').on(table.userId),
  assetIdIdx: index('idx_price_alerts_asset_id').on(table.assetId),
}));

// Relations
export const organizationsRelations = relations(organizations, ({ many }) => ({
  users: many(users),
  wallets: many(wallets),
  transactions: many(transactions),
  holdings: many(holdings),
  insights: many(insights),
}));

export const usersRelations = relations(users, ({ one, many }) => ({
  organization: one(organizations, {
    fields: [users.organizationId],
    references: [organizations.id],
  }),
  wallets: many(wallets),
  newsBookmarks: many(newsBookmarks),
  priceAlerts: many(priceAlerts),
}));

export const walletsRelations = relations(wallets, ({ one, many }) => ({
  organization: one(organizations, {
    fields: [wallets.organizationId],
    references: [organizations.id],
  }),
  user: one(users, {
    fields: [wallets.userId],
    references: [users.id],
  }),
  transactions: many(transactions),
  holdings: many(holdings),
  insights: many(insights),
}));

export const assetsRelations = relations(assets, ({ many }) => ({
  transactions: many(transactions),
  holdings: many(holdings),
  priceSnapshots: many(priceSnapshots),
  priceAlerts: many(priceAlerts),
}));

export const transactionsRelations = relations(transactions, ({ one }) => ({
  organization: one(organizations, {
    fields: [transactions.organizationId],
    references: [organizations.id],
  }),
  wallet: one(wallets, {
    fields: [transactions.walletId],
    references: [wallets.id],
  }),
  asset: one(assets, {
    fields: [transactions.assetId],
    references: [assets.id],
  }),
}));
```

---

## CLERK INTEGRATION

### Setup

```typescript
// middleware.ts
import { authMiddleware } from '@clerk/nextjs';

export default authMiddleware({
  publicRoutes: ['/', '/api/webhooks/clerk'],
  
  afterAuth(auth, req) {
    // Redirecionar usu√°rios n√£o autenticados para sign-in
    if (!auth.userId && !auth.isPublicRoute) {
      const signInUrl = new URL('/sign-in', req.url);
      signInUrl.searchParams.set('redirect_url', req.url);
      return Response.redirect(signInUrl);
    }

    // Redirecionar usu√°rios autenticados de pages p√∫blicas para dashboard
    if (auth.userId && req.nextUrl.pathname === '/') {
      return Response.redirect(new URL('/dashboard', req.url));
    }
  }
});

export const config = {
  matcher: ['/((?!.+\\.[\\w]+$|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

```typescript
// app/layout.tsx
import { ClerkProvider } from '@clerk/nextjs';
import { ptBR } from '@clerk/localizations';

export default function RootLayout({
  children,
}: {
  children: React.Node;
}) {
  return (
    <ClerkProvider localization={ptBR}>
      <html lang="pt-BR">
        <body>{children}</body>
      </html>
    </ClerkProvider>
  );
}
```

### Webhooks

```typescript
// app/api/webhooks/clerk/route.ts
import { Webhook } from 'svix';
import { headers } from 'next/headers';
import { WebhookEvent } from '@clerk/nextjs/server';
import { db } from '@/lib/db';
import { organizations, users } from '@/lib/db/schema';
import { eq } from 'drizzle-orm';

export async function POST(req: Request) {
  // Verificar webhook signature
  const WEBHOOK_SECRET = process.env.CLERK_WEBHOOK_SECRET;
  
  if (!WEBHOOK_SECRET) {
    throw new Error('CLERK_WEBHOOK_SECRET n√£o configurado');
  }

  const headerPayload = headers();
  const svix_id = headerPayload.get('svix-id');
  const svix_timestamp = headerPayload.get('svix-timestamp');
  const svix_signature = headerPayload.get('svix-signature');

  if (!svix_id || !svix_timestamp || !svix_signature) {
    return new Response('Erro: Headers faltando', {
      status: 400,
    });
  }

  const payload = await req.json();
  const body = JSON.stringify(payload);

  const wh = new Webhook(WEBHOOK_SECRET);

  let evt: WebhookEvent;

  try {
    evt = wh.verify(body, {
      'svix-id': svix_id,
      'svix-timestamp': svix_timestamp,
      'svix-signature': svix_signature,
    }) as WebhookEvent;
  } catch (err) {
    console.error('Erro ao verificar webhook:', err);
    return new Response('Erro: Verifica√ß√£o falhou', {
      status: 400,
    });
  }

  const eventType = evt.type;

  // User Created
  if (eventType === 'user.created') {
    const { id, email_addresses, first_name, last_name, image_url } = evt.data;

    // Criar organiza√ß√£o pessoal
    const [org] = await db.insert(organizations).values({
      clerkOrgId: `personal_${id}`,
      name: `${first_name || 'User'}'s Organization`,
      slug: `user-${id.slice(0, 8)}`,
    }).returning();

    // Criar usu√°rio
    await db.insert(users).values({
      clerkUserId: id,
      organizationId: org.id,
      email: email_addresses[0].email_address,
      name: `${first_name || ''} ${last_name || ''}`.trim() || null,
      avatarUrl: image_url || null,
    });
  }

  // User Updated
  if (eventType === 'user.updated') {
    const { id, email_addresses, first_name, last_name, image_url } = evt.data;

    await db.update(users)
      .set({
        email: email_addresses[0].email_address,
        name: `${first_name || ''} ${last_name || ''}`.trim() || null,
        avatarUrl: image_url || null,
        updatedAt: new Date(),
      })
      .where(eq(users.clerkUserId, id));
  }

  // User Deleted
  if (eventType === 'user.deleted') {
    const { id } = evt.data;

    await db.update(users)
      .set({ deletedAt: new Date() })
      .where(eq(users.clerkUserId, id!));
  }

  // Organization Created
  if (eventType === 'organization.created') {
    const { id, name, slug } = evt.data;

    await db.insert(organizations).values({
      clerkOrgId: id,
      name,
      slug: slug || `org-${id.slice(0, 8)}`,
    });
  }

  // Organization Updated
  if (eventType === 'organization.updated') {
    const { id, name, slug } = evt.data;

    await db.update(organizations)
      .set({
        name,
        slug: slug || undefined,
        updatedAt: new Date(),
      })
      .where(eq(organizations.clerkOrgId, id));
  }

  // Organization Deleted
  if (eventType === 'organization.deleted') {
    const { id } = evt.data;

    await db.update(organizations)
      .set({ deletedAt: new Date() })
      .where(eq(organizations.clerkOrgId, id!));
  }

  return new Response('', { status: 200 });
}
```

---

## SUPABASE INTEGRATION

### Client Setup

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

```typescript
// lib/supabase/server.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

export async function createClient() {
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}
```

### RLS Helper

```typescript
// lib/supabase/rls.ts
import { auth } from '@clerk/nextjs';

export async function getOrgContext() {
  const { userId, orgId } = auth();

  if (!userId) {
    throw new Error('N√£o autenticado');
  }

  // Se n√£o tem orgId, usa organiza√ß√£o pessoal
  const effectiveOrgId = orgId || `personal_${userId}`;

  return {
    userId,
    orgId: effectiveOrgId,
  };
}
```

### Storage Setup

```typescript
// lib/supabase/storage.ts
import { createClient } from './server';

export async function uploadReceipt(file: File, transactionId: string) {
  const supabase = await createClient();
  const { userId, orgId } = await getOrgContext();

  const fileExt = file.name.split('.').pop();
  const fileName = `${orgId}/${transactionId}.${fileExt}`;

  const { data, error } = await supabase.storage
    .from('transaction-receipts')
    .upload(fileName, file, {
      cacheControl: '3600',
      upsert: false,
    });

  if (error) throw error;

  const { data: { publicUrl } } = supabase.storage
    .from('transaction-receipts')
    .getPublicUrl(fileName);

  return publicUrl;
}

export async function deleteReceipt(url: string) {
  const supabase = await createClient();
  
  const fileName = url.split('/').slice(-2).join('/');

  const { error } = await supabase.storage
    .from('transaction-receipts')
    .remove([fileName]);

  if (error) throw error;
}
```

---

## RESEND INTEGRATION

### Email Templates

```typescript
// emails/welcome.tsx
import {
  Html,
  Head,
  Body,
  Container,
  Section,
  Text,
  Button,
  Hr,
  Img,
} from '@react-email/components';

interface WelcomeEmailProps {
  userName: string;
  dashboardUrl: string;
}

export function WelcomeEmail({ userName, dashboardUrl }: WelcomeEmailProps) {
  return (
    <Html>
      <Head />
      <Body style={main}>
        <Container style={container}>
          <Img
            src="https://atlascryptofolio.com/logo.png"
            width="48"
            height="48"
            alt="atlascryptofolio"
            style={logo}
          />
          <Text style={heading}>Bem-vindo ao Atlas CryptoFolio, {userName}!</Text>
          <Text style={paragraph}>
            Estamos felizes em t√™-lo conosco. O Atlas CryptoFolio √© a maneira mais
            f√°cil de gerenciar seus investimentos em criptomoedas.
          </Text>
          <Section style={buttonContainer}>
            <Button style={button} href={dashboardUrl}>
              Acessar Dashboard
            </Button>
          </Section>
          <Hr style={hr} />
          <Text style={paragraph}>
            <strong>Pr√≥ximos passos:</strong>
          </Text>
          <Text style={list}>
            1. Crie sua primeira carteira<br />
            2. Adicione suas transa√ß√µes<br />
            3. Explore seus insights personalizados
          </Text>
          <Text style={footer}>
            Se tiver d√∫vidas, responda este email. Estamos aqui para ajudar!
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

const main = {
  backgroundColor: '#f6f9fc',
  fontFamily:
    '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Ubuntu,sans-serif',
};

const container = {
  backgroundColor: '#ffffff',
  margin: '0 auto',
  padding: '20px 0 48px',
  marginBottom: '64px',
};

const logo = {
  margin: '0 auto',
};

const heading = {
  fontSize: '24px',
  letterSpacing: '-0.5px',
  lineHeight: '1.3',
  fontWeight: '400',
  color: '#484848',
  padding: '17px 0 0',
};

const paragraph = {
  margin: '0 0 15px',
  fontSize: '15px',
  lineHeight: '1.4',
  color: '#3c4149',
};

const buttonContainer = {
  padding: '27px 0 27px',
};

const button = {
  backgroundColor: '#3b82f6',
  borderRadius: '3px',
  fontWeight: '600',
  color: '#fff',
  fontSize: '15px',
  textDecoration: 'none',
  textAlign: 'center' as const,
  display: 'block',
  padding: '11px 23px',
};

const hr = {
  borderColor: '#dfe1e4',
  margin: '42px 0 26px',
};

const list = {
  fontSize: '14px',
  lineHeight: '24px',
  color: '#3c4149',
};

const footer = {
  color: '#9ca299',
  fontSize: '14px',
  marginTop: '32px',
};
```

```typescript
// emails/price-alert.tsx
import {
  Html,
  Head,
  Body,
  Container,
  Text,
  Button,
  Hr,
} from '@react-email/components';

interface PriceAlertEmailProps {
  userName: string;
  assetName: string;
  assetSymbol: string;
  currentPrice: string;
  targetPrice: string;
  alertType: 'above' | 'below';
  dashboardUrl: string;
}

export function PriceAlertEmail({
  userName,
  assetName,
  assetSymbol,
  currentPrice,
  targetPrice,
  alertType,
  dashboardUrl,
}: PriceAlertEmailProps) {
  const alertMessage =
    alertType === 'above'
      ? `subiu acima de ${targetPrice}`
      : `caiu abaixo de ${targetPrice}`;

  return (
    <Html>
      <Head />
      <Body style={main}>
        <Container style={container}>
          <Text style={heading}>üö® Alerta de Pre√ßo Ativado!</Text>
          <Text style={paragraph}>Ol√° {userName},</Text>
          <Text style={paragraph}>
            O pre√ßo do <strong>{assetName} ({assetSymbol})</strong> {alertMessage}.
          </Text>
          <Text style={priceText}>
            Pre√ßo atual: <strong>${currentPrice}</strong>
          </Text>
          <Button style={button} href={dashboardUrl}>
            Ver no Dashboard
          </Button>
          <Hr style={hr} />
          <Text style={footer}>
            Este alerta foi configurado em suas prefer√™ncias. Voc√™ pode
            gerenciar seus alertas no dashboard.
          </Text>
        </Container>
      </Body>
    </Html>
  );
}

// Styles similares ao WelcomeEmail
```

### Send Email Action

```typescript
// lib/actions/email.ts
'use server';

import { Resend } from 'resend';
import { WelcomeEmail } from '@/emails/welcome';
import { PriceAlertEmail } from '@/emails/price-alert';

const resend = new Resend(process.env.RESEND_API_KEY);

export async function sendWelcomeEmail(email: string, name: string) {
  const dashboardUrl = `${process.env.NEXT_PUBLIC_URL}/dashboard`;

  try {
    await resend.emails.send({
      from: 'Atlas CryptoFolio <onboarding@atlascryptofolio.com>',
      to: email,
      subject: 'Bem-vindo ao Atlas CryptoFolio! üöÄ',
      react: WelcomeEmail({ userName: name, dashboardUrl }),
    });
  } catch (error) {
    console.error('Erro ao enviar email de boas-vindas:', error);
    // N√£o fazer throw - email √© non-blocking
  }
}

export async function sendPriceAlertEmail(
  email: string,
  userName: string,
  assetName: string,
  assetSymbol: string,
  currentPrice: string,
  targetPrice: string,
  alertType: 'above' | 'below'
) {
  const dashboardUrl = `${process.env.NEXT_PUBLIC_URL}/dashboard`;

  try {
    await resend.emails.send({
      from: 'Atlas CryptoFolio Alerts <alerts@atlascryptofolio.com>',
      to: email,
      subject: `üö® Alerta: ${assetSymbol} ${alertType === 'above' ? 'subiu' : 'caiu'}!`,
      react: PriceAlertEmail({
        userName,
        assetName,
        assetSymbol,
        currentPrice,
        targetPrice,
        alertType,
        dashboardUrl,
      }),
    });
  } catch (error) {
    console.error('Erro ao enviar email de alerta de pre√ßo:', error);
  }
}

export async function sendWeeklyInsights(
  email: string,
  userName: string,
  insights: any[]
) {
  // Similar implementation
}
```

---

## COMPONENTES PRINCIPAIS

### Estrutura de Pastas

```
/app
  /(auth)
    /sign-in/[[...sign-in]]/page.tsx
    /sign-up/[[...sign-up]]/page.tsx
  /(onboarding)
    /onboarding/page.tsx
  /(app)
    /dashboard/page.tsx
    /wallets
      /page.tsx
      /[walletId]/page.tsx
    /transactions
      /page.tsx
      /new/page.tsx
      /[transactionId]/edit/page.tsx
    /insights/page.tsx
    /news/page.tsx
    /settings/page.tsx
  /api
    /webhooks
      /clerk/route.ts
    /cron
      /update-prices/route.ts
      /check-alerts/route.ts
/components
  /dashboard
    /portfolio-summary.tsx
    /performance-chart.tsx
    /assets-table.tsx
    /allocation-chart.tsx
  /wallets
    /wallet-card.tsx
    /wallet-form.tsx
    /wallet-list.tsx
  /transactions
    /transaction-form.tsx
    /transaction-list.tsx
  /insights
    /insight-card.tsx
    /insights-list.tsx
  /news
    /news-feed.tsx
    /news-card.tsx
  /ui (shadcn)
    /button.tsx
    /card.tsx
    /dialog.tsx
    /form.tsx
    /input.tsx
    /select.tsx
    /table.tsx
    /tabs.tsx
    /toast.tsx
  /layout
    /sidebar.tsx
    /header.tsx
    /mobile-nav.tsx
/lib
  /db
    /index.ts
    /schema.ts
    /migrations
  /supabase
    /client.ts
    /server.ts
    /rls.ts
    /storage.ts
  /hooks
    /use-wallets.ts
    /use-transactions.ts
    /use-holdings.ts
    /use-insights.ts
  /actions
    /wallets.ts
    /transactions.ts
    /holdings.ts
    /insights.ts
    /email.ts
  /utils
    /calculations.ts
    /formatters.ts
    /validators.ts
/emails
  /welcome.tsx
  /price-alert.tsx
  /weekly-insights.tsx
```

### Componente: PortfolioSummary

```typescript
// components/dashboard/portfolio-summary.tsx
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ArrowUpIcon, ArrowDownIcon, TrendingUpIcon } from 'lucide-react';
import { useHoldings } from '@/lib/hooks/use-holdings';
import { formatCurrency, formatPercentage } from '@/lib/utils/formatters';
import Decimal from 'decimal.js';

export function PortfolioSummary() {
  const { holdings, isLoading } = useHoldings();

  if (isLoading) {
    return <PortfolioSummarySkeleton />;
  }

  // C√°lculos
  const totalValue = holdings.reduce((sum, holding) => {
    const currentPrice = new Decimal(holding.asset.currentPriceUsd || 0);
    const quantity = new Decimal(holding.totalQuantity);
    return sum.plus(currentPrice.times(quantity));
  }, new Decimal(0));

  const totalInvested = holdings.reduce((sum, holding) => {
    return sum.plus(new Decimal(holding.totalInvestedUsd));
  }, new Decimal(0));

  const unrealizedPnL = totalValue.minus(totalInvested);
  const unrealizedPnLPercent = totalInvested.greaterThan(0)
    ? unrealizedPnL.dividedBy(totalInvested).times(100)
    : new Decimal(0);

  const totalRealizedPnL = holdings.reduce((sum, holding) => {
    return sum.plus(new Decimal(holding.realizedPnlUsd));
  }, new Decimal(0));

  // Varia√ß√£o 24h (simplificado)
  const change24h = new Decimal(2.5); // Calcular baseado em price_snapshots
  const isPositive = change24h.greaterThanOrEqualTo(0);

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Valor Total</CardTitle>
          <TrendingUpIcon className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {formatCurrency(totalValue.toNumber())}
          </div>
          <p className="text-xs text-muted-foreground">
            Investido: {formatCurrency(totalInvested.toNumber())}
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Varia√ß√£o 24h</CardTitle>
          {isPositive ? (
            <ArrowUpIcon className="h-4 w-4 text-green-600" />
          ) : (
            <ArrowDownIcon className="h-4 w-4 text-red-600" />
          )}
        </CardHeader>
        <CardContent>
          <div
            className={`text-2xl font-bold ${
              isPositive ? 'text-green-600' : 'text-red-600'
            }`}
          >
            {formatPercentage(change24h.toNumber())}
          </div>
          <p className="text-xs text-muted-foreground">√öltimas 24 horas</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">P&L N√£o Realizado</CardTitle>
        </CardHeader>
        <CardContent>
          <div
            className={`text-2xl font-bold ${
              unrealizedPnL.greaterThanOrEqualTo(0)
                ? 'text-green-600'
                : 'text-red-600'
            }`}
          >
            {formatCurrency(unrealizedPnL.toNumber())}
          </div>
          <p className="text-xs text-muted-foreground">
            {formatPercentage(unrealizedPnLPercent.toNumber())}
          </p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">P&L Realizado</CardTitle>
        </CardHeader>
        <CardContent>
          <div
            className={`text-2xl font-bold ${
              totalRealizedPnL.greaterThanOrEqualTo(0)
                ? 'text-green-600'
                : 'text-red-600'
            }`}
          >
            {formatCurrency(totalRealizedPnL.toNumber())}
          </div>
          <p className="text-xs text-muted-foreground">Vendas realizadas</p>
        </CardContent>
      </Card>
    </div>
  );
}

function PortfolioSummarySkeleton() {
  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      {[...Array(4)].map((_, i) => (
        <Card key={i}>
          <CardHeader className="space-y-0 pb-2">
            <div className="h-4 w-24 bg-muted animate-pulse rounded" />
          </CardHeader>
          <CardContent>
            <div className="h-8 w-32 bg-muted animate-pulse rounded mb-2" />
            <div className="h-3 w-20 bg-muted animate-pulse rounded" />
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
```

### Componente: TransactionForm

```typescript
// components/transactions/transaction-form.tsx
'use client';

import { zodResolver } from '@hookform/resolvers/zod';
import { useForm } from 'react-hook-form';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { createTransaction } from '@/lib/actions/transactions';
import { toast } from 'sonner';

const transactionSchema = z.object({
  walletId: z.string().uuid(),
  assetId: z.string().uuid(),
  type: z.enum(['buy', 'sell', 'transfer', 'airdrop']),
  quantity: z.string().regex(/^\d+(\.\d+)?$/, 'Quantidade inv√°lida'),
  pricePerUnit: z.string().regex(/^\d+(\.\d+)?$/, 'Pre√ßo inv√°lido'),
  fee: z.string().regex(/^\d+(\.\d+)?$/, 'Taxa inv√°lida').optional(),
  exchange: z.string().optional(),
  notes: z.string().optional(),
  transactionDate: z.string(),
});

type TransactionFormValues = z.infer<typeof transactionSchema>;

interface TransactionFormProps {
  walletId?: string;
  onSuccess?: () => void;
}

export function TransactionForm({ walletId, onSuccess }: TransactionFormProps) {
  const form = useForm<TransactionFormValues>({
    resolver: zodResolver(transactionSchema),
    defaultValues: {
      walletId: walletId || '',
      type: 'buy',
      transactionDate: new Date().toISOString().split('T')[0],
    },
  });

  const onSubmit = async (data: TransactionFormValues) => {
    try {
      const result = await createTransaction(data);
      
      if (result.success) {
        toast.success('Transa√ß√£o criada com sucesso!');
        form.reset();
        onSuccess?.();
      } else {
        toast.error(result.error || 'Erro ao criar transa√ß√£o');
      }
    } catch (error) {
      toast.error('Erro inesperado ao criar transa√ß√£o');
      console.error(error);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="type"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Tipo de Transa√ß√£o</FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder="Selecione o tipo" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  <SelectItem value="buy">Compra</SelectItem>
                  <SelectItem value="sell">Venda</SelectItem>
                  <SelectItem value="transfer">Transfer√™ncia</SelectItem>
                  <SelectItem value="airdrop">Airdrop/Reward</SelectItem>
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* AssetSearch Component */}
        <FormField
          control={form.control}
          name="assetId"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Ativo</FormLabel>
              <FormControl>
                <AssetSearch
                  value={field.value}
                  onChange={field.onChange}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid grid-cols-2 gap-4">
          <FormField
            control={form.control}
            name="quantity"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Quantidade</FormLabel>
                <FormControl>
                  <Input
                    placeholder="0.05"
                    {...field}
                    type="text"
                    inputMode="decimal"
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="pricePerUnit"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Pre√ßo Unit√°rio (USD)</FormLabel>
                <FormControl>
                  <Input
                    placeholder="45000.00"
                    {...field}
                    type="text"
                    inputMode="decimal"
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={form.control}
          name="transactionDate"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Data da Transa√ß√£o</FormLabel>
              <FormControl>
                <Input type="date" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="notes"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Notas (opcional)</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Observa√ß√µes sobre esta transa√ß√£o..."
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" className="w-full" disabled={form.formState.isSubmitting}>
          {form.formState.isSubmitting ? 'Criando...' : 'Criar Transa√ß√£o'}
        </Button>
      </form>
    </Form>
  );
}
```

### Componente: PerformanceChart

```typescript
// components/dashboard/performance-chart.tsx
'use client';

import { useState } from 'react';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { usePerformanceData } from '@/lib/hooks/use-performance-data';
import { formatCurrency } from '@/lib/utils/formatters';

type Period = '7d' | '30d' | '90d' | '1y' | 'all';

export function PerformanceChart() {
  const [period, setPeriod] = useState<Period>('30d');
  const { data, isLoading } = usePerformanceData(period);

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>Performance do Portf√≥lio</CardTitle>
          <Tabs value={period} onValueChange={(v) => setPeriod(v as Period)}>
            <TabsList>
              <TabsTrigger value="7d">7D</TabsTrigger>
              <TabsTrigger value="30d">30D</TabsTrigger>
              <TabsTrigger value="90d">90D</TabsTrigger>
              <TabsTrigger value="1y">1A</TabsTrigger>
              <TabsTrigger value="all">Tudo</TabsTrigger>
            </TabsList>
          </Tabs>
        </div>
      </CardHeader>
      <CardContent>
        {isLoading ? (
          <div className="h-[300px] w-full animate-pulse bg-muted rounded" />
        ) : (
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
              <XAxis
                dataKey="date"
                className="text-xs"
                tickFormatter={(value) =>
                  new Date(value).toLocaleDateString('pt-BR', {
                    month: 'short',
                    day: 'numeric',
                  })
                }
              />
              <YAxis
                className="text-xs"
                tickFormatter={(value) => formatCurrency(value, { compact: true })}
              />
              <Tooltip
                contentStyle={{
                  backgroundColor: 'hsl(var(--popover))',
                  border: '1px solid hsl(var(--border))',
                  borderRadius: '6px',
                }}
                formatter={(value: number) => [formatCurrency(value), 'Valor']}
                labelFormatter={(label) =>
                  new Date(label).toLocaleDateString('pt-BR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                  })
                }
              />
              <Line
                type="monotone"
                dataKey="value"
                stroke="hsl(var(--primary))"
                strokeWidth={2}
                dot={false}
                activeDot={{ r: 4 }}
              />
            </LineChart>
          </ResponsiveContainer>
        )}
      </CardContent>
    </Card>
  );
}
```

---

## DESIGN SYSTEM

### Cores (Tailwind Config)

```javascript
// tailwind.config.ts
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        // Custom colors for crypto
        green: {
          500: '#10b981',
          600: '#059669',
        },
        red: {
          500: '#ef4444',
          600: '#dc2626',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};

export default config;
```

```css
/* app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    --primary: 221.2 83.2% 53.3%; /* Blue */
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;

    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

### Typography

```typescript
// lib/utils/typography.ts
export const typography = {
  h1: 'scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl',
  h2: 'scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0',
  h3: 'scroll-m-20 text-2xl font-semibold tracking-tight',
  h4: 'scroll-m-20 text-xl font-semibold tracking-tight',
  p: 'leading-7 [&:not(:first-child)]:mt-6',
  lead: 'text-xl text-muted-foreground',
  large: 'text-lg font-semibold',
  small: 'text-sm font-medium leading-none',
  muted: 'text-sm text-muted-foreground',
};
```

### Componentes Base (shadcn/ui)

Componentes necess√°rios via CLI:
```bash
npx shadcn-ui@latest add button
npx shadcn-ui@latest add card
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add dropdown-menu
npx shadcn-ui@latest add form
npx shadcn-ui@latest add input
npx shadcn-ui@latest add label
npx shadcn-ui@latest add select
npx shadcn-ui@latest add separator
npx shadcn-ui@latest add table
npx shadcn-ui@latest add tabs
npx shadcn-ui@latest add textarea
npx shadcn-ui@latest add toast
npx shadcn-ui@latest add tooltip
npx shadcn-ui@latest add skeleton
npx shadcn-ui@latest add badge
npx shadcn-ui@latest add avatar
npx shadcn-ui@latest add alert
```

---

## SERVER ACTIONS

### Padr√£o de Implementa√ß√£o

```typescript
// lib/actions/transactions.ts
'use server';

import { auth } from '@clerk/nextjs';
import { db } from '@/lib/db';
import { transactions, holdings } from '@/lib/db/schema';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import Decimal from 'decimal.js';
import { eq, and } from 'drizzle-orm';
import { getOrgContext } from '@/lib/supabase/rls';

const createTransactionSchema = z.object({
  walletId: z.string().uuid(),
  assetId: z.string().uuid(),
  type: z.enum(['buy', 'sell', 'transfer', 'airdrop']),
  quantity: z.string(),
  pricePerUnit: z.string(),
  fee: z.string().optional(),
  exchange: z.string().optional(),
  notes: z.string().optional(),
  transactionDate: z.string(),
});

export async function createTransaction(
  data: z.infer<typeof createTransactionSchema>
) {
  try {
    const { userId, orgId } = await getOrgContext();

    // Validar dados
    const validated = createTransactionSchema.parse(data);

    // Converter para Decimal para precis√£o
    const quantity = new Decimal(validated.quantity);
    const pricePerUnit = new Decimal(validated.pricePerUnit);
    const fee = validated.fee ? new Decimal(validated.fee) : new Decimal(0);
    const totalValue = quantity.times(pricePerUnit);

    // Para vendas, validar que h√° quantidade suficiente
    if (validated.type === 'sell') {
      const [holding] = await db
        .select()
        .from(holdings)
        .where(
          and(
            eq(holdings.organizationId, orgId),
            eq(holdings.walletId, validated.walletId),
            eq(holdings.assetId, validated.assetId)
          )
        );

      if (!holding || new Decimal(holding.totalQuantity).lessThan(quantity)) {
        return {
          success: false,
          error: 'Quantidade insuficiente para venda',
        };
      }
    }

    // Criar transa√ß√£o
    const [transaction] = await db
      .insert(transactions)
      .values({
        organizationId: orgId,
        walletId: validated.walletId,
        assetId: validated.assetId,
        type: validated.type,
        quantity: quantity.toString(),
        pricePerUnitUsd: pricePerUnit.toString(),
        totalValueUsd: totalValue.toString(),
        feeUsd: fee.toString(),
        exchange: validated.exchange,
        notes: validated.notes,
        transactionDate: new Date(validated.transactionDate),
      })
      .returning();

    // Recalcular holdings
    await recalculateHoldings(validated.walletId, validated.assetId, orgId);

    // Revalidar caches
    revalidatePath('/dashboard');
    revalidatePath(`/wallets/${validated.walletId}`);

    return {
      success: true,
      data: transaction,
    };
  } catch (error) {
    console.error('Erro ao criar transa√ß√£o:', error);
    return {
      success: false,
      error: 'Erro ao criar transa√ß√£o',
    };
  }
}

async function recalculateHoldings(
  walletId: string,
  assetId: string,
  orgId: string
) {
  // Buscar todas as transa√ß√µes deste ativo na wallet
  const allTransactions = await db
    .select()
    .from(transactions)
    .where(
      and(
        eq(transactions.organizationId, orgId),
        eq(transactions.walletId, walletId),
        eq(transactions.assetId, assetId),
        eq(transactions.deletedAt, null)
      )
    )
    .orderBy(transactions.transactionDate);

  // Implementar c√°lculo FIFO
  let totalQuantity = new Decimal(0);
  let totalInvested = new Decimal(0);
  let realizedPnL = new Decimal(0);
  const buyQueue: Array<{ quantity: Decimal; price: Decimal }> = [];

  for (const tx of allTransactions) {
    const qty = new Decimal(tx.quantity);
    const price = new Decimal(tx.pricePerUnitUsd);

    if (tx.type === 'buy' || tx.type === 'airdrop') {
      totalQuantity = totalQuantity.plus(qty);
      totalInvested = totalInvested.plus(qty.times(price));
      buyQueue.push({ quantity: qty, price });
    } else if (tx.type === 'sell') {
      let remainingToSell = qty;
      
      while (remainingToSell.greaterThan(0) && buyQueue.length > 0) {
        const oldestBuy = buyQueue[0];
        
        if (oldestBuy.quantity.greaterThanOrEqualTo(remainingToSell)) {
          // Venda parcial desta compra
          const soldValue = remainingToSell.times(price);
          const costBasis = remainingToSell.times(oldestBuy.price);
          realizedPnL = realizedPnL.plus(soldValue.minus(costBasis));
          
          oldestBuy.quantity = oldestBuy.quantity.minus(remainingToSell);
          totalQuantity = totalQuantity.minus(remainingToSell);
          totalInvested = totalInvested.minus(costBasis);
          
          if (oldestBuy.quantity.isZero()) {
            buyQueue.shift();
          }
          
          remainingToSell = new Decimal(0);
        } else {
          // Venda completa desta compra
          const soldValue = oldestBuy.quantity.times(price);
          const costBasis = oldestBuy.quantity.times(oldestBuy.price);
          realizedPnL = realizedPnL.plus(soldValue.minus(costBasis));
          
          totalQuantity = totalQuantity.minus(oldestBuy.quantity);
          totalInvested = totalInvested.minus(costBasis);
          remainingToSell = remainingToSell.minus(oldestBuy.quantity);
          
          buyQueue.shift();
        }
      }
    }
  }

  // Calcular pre√ßo m√©dio
  const averagePrice = totalQuantity.greaterThan(0)
    ? totalInvested.dividedBy(totalQuantity)
    : new Decimal(0);

  // Atualizar ou criar holding
  await db
    .insert(holdings)
    .values({
      organizationId: orgId,
      walletId,
      assetId,
      totalQuantity: totalQuantity.toString(),
      averageBuyPriceUsd: averagePrice.toString(),
      totalInvestedUsd: totalInvested.toString(),
      realizedPnlUsd: realizedPnL.toString(),
      lastCalculatedAt: new Date(),
    })
    .onConflictDoUpdate({
      target: [holdings.walletId, holdings.assetId],
      set: {
        totalQuantity: totalQuantity.toString(),
        averageBuyPriceUsd: averagePrice.toString(),
        totalInvestedUsd: totalInvested.toString(),
        realizedPnlUsd: realizedPnL.toString(),
        lastCalculatedAt: new Date(),
        updatedAt: new Date(),
      },
    });
}

export async function deleteTransaction(transactionId: string) {
  try {
    const { orgId } = await getOrgContext();

    // Buscar transa√ß√£o para soft delete e recalcular
    const [transaction] = await db
      .select()
      .from(transactions)
      .where(
        and(
          eq(transactions.id, transactionId),
          eq(transactions.organizationId, orgId)
        )
      );

    if (!transaction) {
      return { success: false, error: 'Transa√ß√£o n√£o encontrada' };
    }

    // Soft delete
    await db
      .update(transactions)
      .set({ deletedAt: new Date() })
      .where(eq(transactions.id, transactionId));

    // Recalcular holdings
    await recalculateHoldings(
      transaction.walletId,
      transaction.assetId,
      orgId
    );

    revalidatePath('/dashboard');
    revalidatePath(`/wallets/${transaction.walletId}`);

    return { success: true };
  } catch (error) {
    console.error('Erro ao deletar transa√ß√£o:', error);
    return { success: false, error: 'Erro ao deletar transa√ß√£o' };
  }
}
```

### Outros Server Actions

```typescript
// lib/actions/wallets.ts
'use server';

import { auth } from '@clerk/nextjs';
import { db } from '@/lib/db';
import { wallets } from '@/lib/db/schema';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { getOrgContext } from '@/lib/supabase/rls';

const createWalletSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().optional(),
  goal: z.string().optional(),
  color: z.string().regex(/^#[0-9A-F]{6}$/i).optional(),
  icon: z.string().optional(),
});

export async function createWallet(data: z.infer<typeof createWalletSchema>) {
  try {
    const { userId, orgId } = await getOrgContext();

    const validated = createWalletSchema.parse(data);

    const [wallet] = await db
      .insert(wallets)
      .values({
        organizationId: orgId,
        userId,
        ...validated,
      })
      .returning();

    revalidatePath('/dashboard');
    revalidatePath('/wallets');

    return { success: true, data: wallet };
  } catch (error) {
    console.error('Erro ao criar wallet:', error);
    return { success: false, error: 'Erro ao criar carteira' };
  }
}

// Similar: updateWallet, deleteWallet, setDefaultWallet
```

---

## SEGURAN√áA

### Checklist

‚úÖ RLS habilitado em todas as tabelas
‚úÖ Todas as queries filtram por organization_id
‚úÖ Server Actions validam auth() via Clerk
‚úÖ Zod validation em todos os forms e server actions
‚úÖ Vari√°veis de ambiente seguras (nunca committadas)
‚úÖ CORS configurado no Supabase
‚úÖ Rate limiting via Vercel (100 req/min)
‚úÖ Inputs sanitizados antes de salvar
‚úÖ Drizzle ORM com prepared statements (anti-SQL injection)
‚úÖ Webhooks validados com signature (Clerk via Svix)

### Exemplo de Query Segura

```typescript
// ‚úÖ CORRETO - Sempre filtrar por orgId
export async function getWallets() {
  const { orgId } = await getOrgContext();

  const data = await db.query.wallets.findMany({
    where: (wallets, { eq, and, isNull }) =>
      and(
        eq(wallets.organizationId, orgId),
        isNull(wallets.deletedAt)
      ),
    orderBy: (wallets, { desc }) => [desc(wallets.createdAt)],
  });

  return data;
}

// ‚ùå ERRADO - N√£o filtrar = vazamento de dados
export async function getWallets() {
  const data = await db.query.wallets.findMany(); // NUNCA FAZER ISSO
  return data;
}
```

### Valida√ß√£o de Inputs

```typescript
// Sempre usar Zod para validar inputs
import { z } from 'zod';

const transactionSchema = z.object({
  quantity: z.string()
    .regex(/^\d+(\.\d+)?$/)
    .refine((val) => parseFloat(val) > 0, 'Quantidade deve ser positiva'),
  pricePerUnit: z.string()
    .regex(/^\d+(\.\d+)?$/)
    .refine((val) => parseFloat(val) > 0, 'Pre√ßo deve ser positivo'),
});

// Em Server Action
export async function createTransaction(rawData: unknown) {
  try {
    const validated = transactionSchema.parse(rawData); // Vai lan√ßar erro se inv√°lido
    // ... resto da l√≥gica
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { success: false, errors: error.errors };
    }
    throw error;
  }
}
```

---

## PERFORMANCE

### Otimiza√ß√µes

- **React Server Components**: Usar RSC para componentes que n√£o precisam de interatividade
- **Streaming SSR**: Usar Suspense boundaries para streaming de dados
- **Image optimization**: Usar next/image para todas as imagens (logos de crypto)
- **Edge Functions**: Deploy no Vercel Edge para lat√™ncia m√≠nima
- **Database Indexes**: Criar indexes em colunas frequentemente consultadas
- **Caching**:
  - Next.js cache para Server Components
  - TanStack Query para cache client-side
  - Revalida√ß√£o inteligente com `revalidatePath`
- **Code Splitting**: Lazy load de componentes pesados (gr√°ficos)
- **Bundle Analysis**: Monitorar bundle size com `@next/bundle-analyzer`

### Implementa√ß√£o de Caching

```typescript
// lib/hooks/use-holdings.ts
'use client';

import { useQuery } from '@tanstack/react-query';
import { getHoldings } from '@/lib/actions/holdings';

export function useHoldings(walletId?: string) {
  return useQuery({
    queryKey: ['holdings', walletId],
    queryFn: () => getHoldings(walletId),
    staleTime: 60 * 1000, // 1 minuto
    cacheTime: 5 * 60 * 1000, // 5 minutos
    refetchInterval: 60 * 1000, // Refetch a cada 1 minuto
  });
}
```

### Lazy Loading

```typescript
// app/dashboard/page.tsx
import dynamic from 'next/dynamic';
import { Suspense } from 'react';

// Lazy load gr√°ficos pesados
const PerformanceChart = dynamic(
  () => import('@/components/dashboard/performance-chart'),
  {
    loading: () => <ChartSkeleton />,
    ssr: false, // N√£o renderizar no servidor
  }
);

export default function DashboardPage() {
  return (
    <div>
      <PortfolioSummary />
      
      <Suspense fallback={<ChartSkeleton />}>
        <PerformanceChart />
      </Suspense>
    </div>
  );
}
```

### Metas

- **First Contentful Paint**: < 1.5s
- **Time to Interactive**: < 3s
- **Lighthouse Score**: > 90
- **Core Web Vitals**:
  - LCP (Largest Contentful Paint): < 2.5s
  - FID (First Input Delay): < 100ms
  - CLS (Cumulative Layout Shift): < 0.1

---

## GITHUB WORKFLOW

### Branch Strategy

```
main (produ√ß√£o - auto-deploy para Vercel)
  ‚îî‚îÄ‚îÄ develop (staging - auto-deploy para Vercel Preview)
       ‚îî‚îÄ‚îÄ feature/* (desenvolvimento)
```

**Regras:**
- `main`: Apenas merges via PR aprovados
- `develop`: Merges de features completas
- `feature/*`: Branches individuais por funcionalidade
- Nomenclatura: `feature/add-transaction-form`, `fix/price-calculation-bug`

### CI/CD Pipeline

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  lint-and-type-check:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run ESLint
        run: npm run lint
      
      - name: Type check
        run: npm run type-check
  
  build:
    runs-on